//? #version 430

//? uniform int NumberOfComputationsX;
//? uniform int NumberOfComputationsY;
//? uniform int NumberOfComputationsZ;

uniform float _dt;
uniform float _air_damping;
uniform float _stiffness;
uniform float _gravity;
uniform vec2 _mouse_pos;

uniform float _time;
uniform float _amplitude;
uniform float _pulsation;

//? #define __bindingIN__  1
//? #define __bindingOUT__ 2
layout(std430, binding=__bindingIN__) buffer particlePositions__bindingIN__ {
   vec2 partPosIN[];
};
layout(std430, binding=__bindingOUT__) buffer particlePositions__bindingOUT__ {
   vec2 partPosOUT[];
};

layout(std430, binding=3) buffer particleVelocities {
   vec2 partVel[];
};
layout(std430, binding=4) buffer heldParticle {
   unsigned int heldPart[];
};

void cool_main(){
    uint gid = gl_GlobalInvocationID.x;
    if (gid != heldPart[0]) {
        if (gid > 0 && gid < NumberOfComputationsX - 1) {
            vec2 dirL = partPosIN[gid] - partPosIN[gid - 1];
            vec2 dirR = partPosIN[gid] - partPosIN[gid + 1];
            vec2 acc = 
                - (dirL + dirR) * _stiffness * NumberOfComputationsX  // Spring attraction
                - partVel[gid] * _air_damping // Air friction
                + vec2(0., -_gravity)         // Gravity
            ;
            // apply
            partVel[gid] += acc * _dt;
            partPosOUT[gid] = partPosIN[gid] + partVel[gid] * _dt;
        }
        else if (gid == 0) {
            partPosOUT[gid] = vec2(
                partPosIN[gid].x,
                _amplitude * sin(_time * _pulsation)
            );
        }
        else {
            partPosOUT[gid] = vec2(
                partPosIN[gid].x,
                _amplitude * sin(_time * _pulsation)
            );
        }
    }
    else {
        partPosOUT[gid] = _mouse_pos;
    }
}